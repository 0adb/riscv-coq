rename value GHC.Num.- = Coq.ZArith.BinInt.Z.sub
rename value GHC.Num.+ = Coq.ZArith.BinInt.Z.add
rename value GHC.Num.* = Coq.ZArith.BinInt.Z.mul
rename value Data.Bits.zeroBits = Coq.ZArith.BinInt.Z0
rename value Data.Bits.complement = Coq.ZArith.BinInt.Z.lnot

rewrite forall, GHC.Num.negate = Coq.ZArith.BinInt.Z.opp
rewrite forall x y, x GHC.Base.== y = Coq.ZArith.BinInt.Z.eqb x y
rewrite forall x y, x GHC.Base.< y = Coq.ZArith.BinInt.Z.ltb x y
rewrite forall x y, x GHC.Base.<= y = Coq.ZArith.BinInt.Z.leb x y
rewrite forall x y, x GHC.Base.> y = Coq.ZArith.BinInt.Z.gtb x y
rewrite forall x y, x GHC.Base.>= y = Coq.ZArith.BinInt.Z.geb x y

rewrite forall x, GHC.Num.fromInteger x = x
rewrite forall x, GHC.Real.fromInteger x = x

rename value Data.Bits..&.        = Coq.ZArith.BinInt.Z.land
rename value Data.Bits.shift      = Coq.ZArith.BinInt.Z.shiftl
rename value Data.Bits.shiftL     = Coq.ZArith.BinInt.Z.shiftl
rename value Data.Bits..|.        = Coq.ZArith.BinInt.Z.lor
rename value Data.Bits.xor        = Coq.ZArith.BinInt.Z.lxor
rename value Data.Bits.testBit    = Coq.ZArith.BinInt.Z.testbit

rewrite forall x, GHC.Num.fromInteger x = x

rewrite forall x y, x GHC.Base.== y = Coq.ZArith.BinInt.Z.eqb x y
rewrite forall x y, x GHC.Base./= y = Coq.ZArith.BinInt.Z.eqb x y

rename value Control.Monad.unless = Utility.unless

rewrite forall x y, Spec.ExecuteV.take_machineInt x y = List.upto x y
skip Spec.ExecuteV.take_machineInt

rewrite forall x y, Spec.ExecuteV.drop_machineInt x y = List.from x y
skip Spec.ExecuteV.drop_machineInt

rewrite forall x, Spec.ExecuteV.length_machineInt x = Coq.ZArith.BinInt.Z.of_nat (length x)
skip Spec.ExecuteV.length_machineInt

rewrite forall x y, Spec.ExecuteV.index_machineInt x y = List.get x y
skip Spec.ExecuteV.index_machineInt

rename type  GHC.Maybe.Maybe   = option
rename value GHC.Maybe.Just    = Some
rename value GHC.Maybe.Nothing = None

rename type GHC.Int.Int8 = w8
rename type GHC.Word.Word8 = w8


rewrite forall, Spec.ExecuteV.int8_toWord8 = (fun x => x)
skip Spec.ExecuteV.int8_toWord8
rewrite forall, Spec.ExecuteV.word8_toInt8 = (fun x => x)
skip Spec.ExecuteV.word8_toInt8

rewrite forall x y, Data.Maybe.fromMaybe x y = match y with | Some y' => y' | None => x end

rewrite forall l, Data.Foldable.and l = forallb (fun x => x) l

rewrite forall l f, Data.Traversable.forM l f = Utility.forM l f 

rewrite forall l f, Data.Foldable.forM_ l f = Utility.forM_ l f

rewrite forall x y, GHC.Enum.enumFromTo x y = Utility.rangeNonNegZ x y

rewrite forall x y, GHC.Real.quot x y = Coq.ZArith.BinInt.Z.quot x y

rewrite forall x y, GHC.Real.rem x y = Coq.ZArith.BinInt.Z.quot x y

rewrite forall x y, Spec.ExecuteV.testBit_machineInt x y = Coq.ZArith.BinInt.Z.testbit (w8_toZ x) y
skip Spec.ExecuteV.testBit_machineInt

rewrite forall x y, Spec.Machine.raiseException x y = Machine.raiseException (ZToReg x) (ZToReg y)

rewrite forall x y, Spec.ExecuteV.translateOffsetAddr x y = Utility.add x (ZToReg i)
skip Spec.ExecuteV.translateOffsetAddr

rewrite forall x, Spec.ExecuteV.zeroToExclusive_machineInt x = Utility.rangeNonNegZ 0 x
skip Spec.ExecuteV.zeroToExclusive_machineInt

rewrite forall x y z, Spec.VirtualMemory.translate x y z = VirtualMemory.translate x (ZToReg y) z

rename value Utility.Utility.combineBytes = Utility.combineW8_toZ

rename value Utility.Utility.splitBytes = Utility.splitZ_toW8


rewrite forall, Spec.ExecuteV.replicate_machineInt = Utility.Utility.repeat_ZtoW8
skip Spec.ExecuteV.replicate_machineInt

rename value Utility.Utility.regToInt64 = Utility.Utility.regToZ_unsigned
