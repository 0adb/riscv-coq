rewrite forall x, GHC.Num.fromInteger x = x
rewrite forall x, GHC.Real.fromIntegral x = x

rewrite forall x y, x GHC.Base.== y = Coq.ZArith.BinInt.Z.eqb x y
rewrite forall x y, x GHC.Base./= y = Coq.ZArith.BinInt.Z.eqb x y

rename value Control.Monad.unless = Utility.unless

rewrite forall x y, Spec.ExecuteV.take_machineInt x y = upto x y
skip Spec.ExecuteV.take_machineInt

rewrite forall x y, Spec.ExecuteV.drop_machineInt x y = from x y
skip Spec.ExecuteV.drop_machineInt

rewrite forall x, Spec.ExecuteV.length_machineInt x  = len x 
skip Spec.ExecuteV.length_machineInt

rewrite forall x y, Spec.ExecuteV.replicate_machineInt x y = repeat x yx
skip Spec.ExecuteV.replicate_machineInt

rewrite forall x y, Spec.ExecuteV.index_machineInt x y = get x y
skip Spec.ExecuteV.index_machineInt

rename type  GHC.Maybe.Maybe   = option
rename value GHC.Maybe.Just    = Some
rename value GHC.Maybe.Nothing = None

rename type GHC.Int.Int8 = byte
rename type GHC.Word.Word8 = byte

rewrite forall x, Spec.ExecuteV.int8_toWord8 x = x
skip Spec.ExecuteV.int8_toWord8

rewrite forall x, Spec.ExecuteV.word8_toInt8 x = x
skip Spec.ExecuteV.word8_toInt8

rewrite forall x y, Data.Maybe.fromMaybe x y = match y with | Some y' => y' | None => x end

rewrite forall l, Data.Foldable.and l = forallb (fun x => x) l

rewrite forall l f, Data.Traversable.forM l f = Utility.forM l f 

rewrite forall l f, Data.Foldable.forM_ l f = Utility.forM_ l f

rewrite forall x y, GHC.Enum.enumFromTo x y = Utility.rangeNonNegZ x y

rewrite forall x y, GHC.Real.quot x y = Z.quot x y

rewrite forall x y, GHC.Real.rem x y = Z.quot x y

rewrite forall x y, Spec.ExecuteV.testBit_machineInt x y = Coq.ZArith.BinInt.Z.testbit
skip Spec.ExecuteV.testBit_machineInt

