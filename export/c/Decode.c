// This C file was autogenerated from Coq
#include <stdbool.h>

#define Register int

#define Opcode int

typedef enum {RV32I, RV32IM, RV32IA, RV32IMA, RV64I, RV64IM, RV64IA, RV64IMA} InstructionSet;

typedef enum {K_Mulw, K_Divw, K_Divuw, K_Remw, K_Remuw, K_InvalidM64} InstructionM64_kind;

typedef struct {
    InstructionM64_kind kind;
    union {
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Mulw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Divw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Divuw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Remw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Remuw;
        struct {
        } as_InvalidM64;
    };
} InstructionM64;

typedef enum {K_Mul, K_Mulh, K_Mulhsu, K_Mulhu, K_Div, K_Divu, K_Rem, K_Remu, K_InvalidM} InstructionM_kind;

typedef struct {
    InstructionM_kind kind;
    union {
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Mul;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Mulh;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Mulhsu;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Mulhu;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Div;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Divu;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Rem;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Remu;
        struct {
        } as_InvalidM;
    };
} InstructionM;

typedef enum {K_Ld, K_Lwu, K_Addiw, K_Slliw, K_Srliw, K_Sraiw, K_Sd, K_Addw, K_Subw, K_Sllw, K_Srlw, K_Sraw, K_InvalidI64} InstructionI64_kind;

typedef struct {
    InstructionI64_kind kind;
    union {
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Ld;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lwu;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Addiw;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Slliw;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Srliw;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Sraiw;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Sd;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Addw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Subw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Sllw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Srlw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Sraw;
        struct {
        } as_InvalidI64;
    };
} InstructionI64;

typedef enum {K_Lb, K_Lh, K_Lw, K_Lbu, K_Lhu, K_Fence, K_Fence_i, K_Addi, K_Slli, K_Slti, K_Sltiu, K_Xori, K_Ori, K_Andi, K_Srli, K_Srai, K_Auipc, K_Sb, K_Sh, K_Sw, K_Add, K_Sub, K_Sll, K_Slt, K_Sltu, K_Xor, K_Srl, K_Sra, K_Or, K_And, K_Lui, K_Beq, K_Bne, K_Blt, K_Bge, K_Bltu, K_Bgeu, K_Jalr, K_Jal, K_InvalidI} InstructionI_kind;

typedef struct {
    InstructionI_kind kind;
    union {
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lb;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lh;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lw;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lbu;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lhu;
        struct {
            int f0;
            int f1;
        } as_Fence;
        struct {
        } as_Fence_i;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Addi;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Slli;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Slti;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Sltiu;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Xori;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Ori;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Andi;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Srli;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Srai;
        struct {
            Register f0;
            int f1;
        } as_Auipc;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Sb;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Sh;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Sw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Add;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Sub;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Sll;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Slt;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Sltu;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Xor;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Srl;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Sra;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Or;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_And;
        struct {
            Register f0;
            int f1;
        } as_Lui;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Beq;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Bne;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Blt;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Bge;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Bltu;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Bgeu;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Jalr;
        struct {
            Register f0;
            int f1;
        } as_Jal;
        struct {
        } as_InvalidI;
    };
} InstructionI;

typedef enum {K_Ecall, K_Ebreak, K_Uret, K_Sret, K_Mret, K_Wfi, K_Sfence_vma, K_Csrrw, K_Csrrs, K_Csrrc, K_Csrrwi, K_Csrrsi, K_Csrrci, K_InvalidCSR} InstructionCSR_kind;

typedef struct {
    InstructionCSR_kind kind;
    union {
        struct {
        } as_Ecall;
        struct {
        } as_Ebreak;
        struct {
        } as_Uret;
        struct {
        } as_Sret;
        struct {
        } as_Mret;
        struct {
        } as_Wfi;
        struct {
            Register f0;
            Register f1;
        } as_Sfence_vma;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Csrrw;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Csrrs;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Csrrc;
        struct {
            Register f0;
            int f1;
            int f2;
        } as_Csrrwi;
        struct {
            Register f0;
            int f1;
            int f2;
        } as_Csrrsi;
        struct {
            Register f0;
            int f1;
            int f2;
        } as_Csrrci;
        struct {
        } as_InvalidCSR;
    };
} InstructionCSR;

typedef enum {K_Lr_d, K_Sc_d, K_Amoswap_d, K_Amoadd_d, K_Amoand_d, K_Amoor_d, K_Amoxor_d, K_Amomax_d, K_Amomaxu_d, K_Amomin_d, K_Amominu_d, K_InvalidA64} InstructionA64_kind;

typedef struct {
    InstructionA64_kind kind;
    union {
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lr_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Sc_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoswap_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoadd_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoand_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoor_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoxor_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amomax_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amomaxu_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amomin_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amominu_d;
        struct {
        } as_InvalidA64;
    };
} InstructionA64;

typedef enum {K_Lr_w, K_Sc_w, K_Amoswap_w, K_Amoadd_w, K_Amoand_w, K_Amoor_w, K_Amoxor_w, K_Amomax_w, K_Amomaxu_w, K_Amomin_w, K_Amominu_w, K_InvalidA} InstructionA_kind;

typedef struct {
    InstructionA_kind kind;
    union {
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lr_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Sc_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoswap_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoadd_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoand_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoor_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoxor_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amomax_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amomaxu_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amomin_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amominu_w;
        struct {
        } as_InvalidA;
    };
} InstructionA;

typedef enum {K_IInstruction, K_MInstruction, K_AInstruction, K_I64Instruction, K_M64Instruction, K_A64Instruction, K_CSRInstruction, K_InvalidInstruction} Instruction_kind;

typedef struct {
    Instruction_kind kind;
    union {
        struct {
            InstructionI f0;
        } as_IInstruction;
        struct {
            InstructionM f0;
        } as_MInstruction;
        struct {
            InstructionA f0;
        } as_AInstruction;
        struct {
            InstructionI64 f0;
        } as_I64Instruction;
        struct {
            InstructionM64 f0;
        } as_M64Instruction;
        struct {
            InstructionA64 f0;
        } as_A64Instruction;
        struct {
            InstructionCSR f0;
        } as_CSRInstruction;
        struct {
            int f0;
        } as_InvalidInstruction;
    };
} Instruction;

int bitwidth(InstructionSet arg_0__) {
    switch (arg_0__) {
        case RV32I:
            return 0b100000;
        case RV32IM:
            return 0b100000;
        case RV32IA:
            return 0b100000;
        case RV32IMA:
            return 0b100000;
        default:
            return 0b1000000;
    }
}

#define funct12_EBREAK 0b1

#define funct12_ECALL 0b0

#define funct12_MRET 0b1100000010

#define funct12_SRET 0b100000010

#define funct12_URET 0b10

#define funct12_WFI 0b100000101

#define funct3_ADD 0b0

#define funct3_ADDI 0b0

#define funct3_ADDIW 0b0

#define funct3_ADDW 0b0

#define funct3_AMOD 0b11

#define funct3_AMOW 0b10

#define funct3_AND 0b111

#define funct3_ANDI 0b111

#define funct3_BEQ 0b0

#define funct3_BGE 0b101

#define funct3_BGEU 0b111

#define funct3_BLT 0b100

#define funct3_BLTU 0b110

#define funct3_BNE 0b1

#define funct3_CSRRC 0b11

#define funct3_CSRRCI 0b111

#define funct3_CSRRS 0b10

#define funct3_CSRRSI 0b110

#define funct3_CSRRW 0b1

#define funct3_CSRRWI 0b101

#define funct3_DIV 0b100

#define funct3_DIVU 0b101

#define funct3_DIVUW 0b101

#define funct3_DIVW 0b100

#define funct3_FENCE 0b0

#define funct3_FENCE_I 0b1

#define funct3_LB 0b0

#define funct3_LBU 0b100

#define funct3_LD 0b11

#define funct3_LH 0b1

#define funct3_LHU 0b101

#define funct3_LW 0b10

#define funct3_LWU 0b110

#define funct3_MUL 0b0

#define funct3_MULH 0b1

#define funct3_MULHSU 0b10

#define funct3_MULHU 0b11

#define funct3_MULW 0b0

#define funct3_OR 0b110

#define funct3_ORI 0b110

#define funct3_PRIV 0b0

#define funct3_REM 0b110

#define funct3_REMU 0b111

#define funct3_REMUW 0b111

#define funct3_REMW 0b110

#define funct3_SB 0b0

#define funct3_SD 0b11

#define funct3_SH 0b1

#define funct3_SLL 0b1

#define funct3_SLLI 0b1

#define funct3_SLLIW 0b1

#define funct3_SLLW 0b1

#define funct3_SLT 0b10

#define funct3_SLTI 0b10

#define funct3_SLTIU 0b11

#define funct3_SLTU 0b11

#define funct3_SRA 0b101

#define funct3_SRAI 0b101

#define funct3_SRAIW 0b101

#define funct3_SRAW 0b101

#define funct3_SRL 0b101

#define funct3_SRLI 0b101

#define funct3_SRLIW 0b101

#define funct3_SRLW 0b101

#define funct3_SUB 0b0

#define funct3_SUBW 0b0

#define funct3_SW 0b10

#define funct3_XOR 0b100

#define funct3_XORI 0b100

#define funct5_AMOADD 0b0

#define funct5_AMOAND 0b1100

#define funct5_AMOMAX 0b10100

#define funct5_AMOMAXU 0b11100

#define funct5_AMOMIN 0b10000

#define funct5_AMOMINU 0b11000

#define funct5_AMOOR 0b1000

#define funct5_AMOSWAP 0b1

#define funct5_AMOXOR 0b100

#define funct5_LR 0b10

#define funct5_SC 0b11

#define funct6_SLLI 0b0

#define funct6_SRAI 0b10000

#define funct6_SRLI 0b0

#define funct7_ADD 0b0

#define funct7_ADDW 0b0

#define funct7_AND 0b0

#define funct7_DIV 0b1

#define funct7_DIVU 0b1

#define funct7_DIVUW 0b1

#define funct7_DIVW 0b1

#define funct7_MUL 0b1

#define funct7_MULH 0b1

#define funct7_MULHSU 0b1

#define funct7_MULHU 0b1

#define funct7_MULW 0b1

#define funct7_OR 0b0

#define funct7_REM 0b1

#define funct7_REMU 0b1

#define funct7_REMUW 0b1

#define funct7_REMW 0b1

#define funct7_SFENCE_VMA 0b1001

#define funct7_SLL 0b0

#define funct7_SLLIW 0b0

#define funct7_SLLW 0b0

#define funct7_SLT 0b0

#define funct7_SLTU 0b0

#define funct7_SRA 0b100000

#define funct7_SRAIW 0b100000

#define funct7_SRAW 0b100000

#define funct7_SRL 0b0

#define funct7_SRLIW 0b0

#define funct7_SRLW 0b0

#define funct7_SUB 0b100000

#define funct7_SUBW 0b100000

#define funct7_XOR 0b0

bool isValidA(InstructionA inst) {
    switch (inst.kind) {
        case K_InvalidA:
            return false;
        default:
            return true;
    }
}

bool isValidA64(InstructionA64 inst) {
    switch (inst.kind) {
        case K_InvalidA64:
            return false;
        default:
            return true;
    }
}

bool isValidCSR(InstructionCSR inst) {
    switch (inst.kind) {
        case K_InvalidCSR:
            return false;
        default:
            return true;
    }
}

bool isValidI(InstructionI inst) {
    switch (inst.kind) {
        case K_InvalidI:
            return false;
        default:
            return true;
    }
}

bool isValidI64(InstructionI64 inst) {
    switch (inst.kind) {
        case K_InvalidI64:
            return false;
        default:
            return true;
    }
}

bool isValidM(InstructionM inst) {
    switch (inst.kind) {
        case K_InvalidM:
            return false;
        default:
            return true;
    }
}

bool isValidM64(InstructionM64 inst) {
    switch (inst.kind) {
        case K_InvalidM64:
            return false;
        default:
            return true;
    }
}

#define opcode_AMO 0b101111

#define opcode_AUIPC 0b10111

#define opcode_BRANCH 0b1100011

#define opcode_JAL 0b1101111

#define opcode_JALR 0b1100111

#define opcode_LOAD 0b11

#define opcode_LOAD_FP 0b111

#define opcode_LUI 0b110111

#define opcode_MADD 0b1000011

#define opcode_MISC_MEM 0b1111

#define opcode_MSUB 0b1000111

#define opcode_NMADD 0b1001111

#define opcode_NMSUB 0b1001011

#define opcode_OP 0b110011

#define opcode_OP_32 0b111011

#define opcode_OP_FP 0b1010011

#define opcode_OP_IMM 0b10011

#define opcode_OP_IMM_32 0b11011

#define opcode_STORE 0b100011

#define opcode_STORE_FP 0b100111

#define opcode_SYSTEM 0b1110011

bool supportsA(InstructionSet arg_0__) {
    switch (arg_0__) {
        case RV32I:
            return false;
        case RV32IM:
            return false;
        case RV64I:
            return false;
        case RV64IM:
            return false;
        default:
            return true;
    }
}

bool supportsM(InstructionSet arg_0__) {
    switch (arg_0__) {
        case RV32I:
            return false;
        case RV32IA:
            return false;
        case RV64I:
            return false;
        case RV64IA:
            return false;
        default:
            return true;
    }
}

Instruction decode(int iset, InstructionSet inst) {
    // TODO expr:let

}

