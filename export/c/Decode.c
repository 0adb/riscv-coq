// This C file was autogenerated from Coq
#include <stdbool.h>
#include <stdint.h>

#define Register int

#define Opcode int

typedef enum {RV32I, RV32IM, RV32IA, RV32IMA, RV64I, RV64IM, RV64IA, RV64IMA} InstructionSet;

typedef enum {K_Mulw, K_Divw, K_Divuw, K_Remw, K_Remuw, K_InvalidM64} InstructionM64_kind;

typedef struct {
    InstructionM64_kind kind;
    union {
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Mulw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Divw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Divuw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Remw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Remuw;
        struct {
        } as_InvalidM64;
    };
} InstructionM64;

typedef enum {K_Mul, K_Mulh, K_Mulhsu, K_Mulhu, K_Div, K_Divu, K_Rem, K_Remu, K_InvalidM} InstructionM_kind;

typedef struct {
    InstructionM_kind kind;
    union {
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Mul;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Mulh;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Mulhsu;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Mulhu;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Div;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Divu;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Rem;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Remu;
        struct {
        } as_InvalidM;
    };
} InstructionM;

typedef enum {K_Ld, K_Lwu, K_Addiw, K_Slliw, K_Srliw, K_Sraiw, K_Sd, K_Addw, K_Subw, K_Sllw, K_Srlw, K_Sraw, K_InvalidI64} InstructionI64_kind;

typedef struct {
    InstructionI64_kind kind;
    union {
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Ld;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lwu;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Addiw;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Slliw;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Srliw;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Sraiw;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Sd;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Addw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Subw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Sllw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Srlw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Sraw;
        struct {
        } as_InvalidI64;
    };
} InstructionI64;

typedef enum {K_Lb, K_Lh, K_Lw, K_Lbu, K_Lhu, K_Fence, K_Fence_i, K_Addi, K_Slli, K_Slti, K_Sltiu, K_Xori, K_Ori, K_Andi, K_Srli, K_Srai, K_Auipc, K_Sb, K_Sh, K_Sw, K_Add, K_Sub, K_Sll, K_Slt, K_Sltu, K_Xor, K_Srl, K_Sra, K_Or, K_And, K_Lui, K_Beq, K_Bne, K_Blt, K_Bge, K_Bltu, K_Bgeu, K_Jalr, K_Jal, K_InvalidI} InstructionI_kind;

typedef struct {
    InstructionI_kind kind;
    union {
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lb;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lh;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lw;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lbu;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lhu;
        struct {
            int f0;
            int f1;
        } as_Fence;
        struct {
        } as_Fence_i;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Addi;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Slli;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Slti;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Sltiu;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Xori;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Ori;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Andi;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Srli;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Srai;
        struct {
            Register f0;
            int f1;
        } as_Auipc;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Sb;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Sh;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Sw;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Add;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Sub;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Sll;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Slt;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Sltu;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Xor;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Srl;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Sra;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_Or;
        struct {
            Register f0;
            Register f1;
            Register f2;
        } as_And;
        struct {
            Register f0;
            int f1;
        } as_Lui;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Beq;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Bne;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Blt;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Bge;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Bltu;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Bgeu;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Jalr;
        struct {
            Register f0;
            int f1;
        } as_Jal;
        struct {
        } as_InvalidI;
    };
} InstructionI;

typedef enum {K_Ecall, K_Ebreak, K_Uret, K_Sret, K_Mret, K_Wfi, K_Sfence_vma, K_Csrrw, K_Csrrs, K_Csrrc, K_Csrrwi, K_Csrrsi, K_Csrrci, K_InvalidCSR} InstructionCSR_kind;

typedef struct {
    InstructionCSR_kind kind;
    union {
        struct {
        } as_Ecall;
        struct {
        } as_Ebreak;
        struct {
        } as_Uret;
        struct {
        } as_Sret;
        struct {
        } as_Mret;
        struct {
        } as_Wfi;
        struct {
            Register f0;
            Register f1;
        } as_Sfence_vma;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Csrrw;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Csrrs;
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Csrrc;
        struct {
            Register f0;
            int f1;
            int f2;
        } as_Csrrwi;
        struct {
            Register f0;
            int f1;
            int f2;
        } as_Csrrsi;
        struct {
            Register f0;
            int f1;
            int f2;
        } as_Csrrci;
        struct {
        } as_InvalidCSR;
    };
} InstructionCSR;

typedef enum {K_Lr_d, K_Sc_d, K_Amoswap_d, K_Amoadd_d, K_Amoand_d, K_Amoor_d, K_Amoxor_d, K_Amomax_d, K_Amomaxu_d, K_Amomin_d, K_Amominu_d, K_InvalidA64} InstructionA64_kind;

typedef struct {
    InstructionA64_kind kind;
    union {
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lr_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Sc_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoswap_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoadd_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoand_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoor_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoxor_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amomax_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amomaxu_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amomin_d;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amominu_d;
        struct {
        } as_InvalidA64;
    };
} InstructionA64;

typedef enum {K_Lr_w, K_Sc_w, K_Amoswap_w, K_Amoadd_w, K_Amoand_w, K_Amoor_w, K_Amoxor_w, K_Amomax_w, K_Amomaxu_w, K_Amomin_w, K_Amominu_w, K_InvalidA} InstructionA_kind;

typedef struct {
    InstructionA_kind kind;
    union {
        struct {
            Register f0;
            Register f1;
            int f2;
        } as_Lr_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Sc_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoswap_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoadd_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoand_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoor_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amoxor_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amomax_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amomaxu_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amomin_w;
        struct {
            Register f0;
            Register f1;
            Register f2;
            int f3;
        } as_Amominu_w;
        struct {
        } as_InvalidA;
    };
} InstructionA;

typedef enum {K_IInstruction, K_MInstruction, K_AInstruction, K_I64Instruction, K_M64Instruction, K_A64Instruction, K_CSRInstruction, K_InvalidInstruction} Instruction_kind;

typedef struct {
    Instruction_kind kind;
    union {
        struct {
            InstructionI f0;
        } as_IInstruction;
        struct {
            InstructionM f0;
        } as_MInstruction;
        struct {
            InstructionA f0;
        } as_AInstruction;
        struct {
            InstructionI64 f0;
        } as_I64Instruction;
        struct {
            InstructionM64 f0;
        } as_M64Instruction;
        struct {
            InstructionA64 f0;
        } as_A64Instruction;
        struct {
            InstructionCSR f0;
        } as_CSRInstruction;
        struct {
            int f0;
        } as_InvalidInstruction;
    };
} Instruction;

int bitwidth(InstructionSet arg_0__) {
    switch (arg_0__) {
        case RV32I:
            return 0b100000;
        case RV32IM:
            return 0b100000;
        case RV32IA:
            return 0b100000;
        case RV32IMA:
            return 0b100000;
        default:
            return 0b1000000;
    }
}

#define funct12_EBREAK 0b1

#define funct12_ECALL 0b0

#define funct12_MRET 0b1100000010

#define funct12_SRET 0b100000010

#define funct12_URET 0b10

#define funct12_WFI 0b100000101

#define funct3_ADD 0b0

#define funct3_ADDI 0b0

#define funct3_ADDIW 0b0

#define funct3_ADDW 0b0

#define funct3_AMOD 0b11

#define funct3_AMOW 0b10

#define funct3_AND 0b111

#define funct3_ANDI 0b111

#define funct3_BEQ 0b0

#define funct3_BGE 0b101

#define funct3_BGEU 0b111

#define funct3_BLT 0b100

#define funct3_BLTU 0b110

#define funct3_BNE 0b1

#define funct3_CSRRC 0b11

#define funct3_CSRRCI 0b111

#define funct3_CSRRS 0b10

#define funct3_CSRRSI 0b110

#define funct3_CSRRW 0b1

#define funct3_CSRRWI 0b101

#define funct3_DIV 0b100

#define funct3_DIVU 0b101

#define funct3_DIVUW 0b101

#define funct3_DIVW 0b100

#define funct3_FENCE 0b0

#define funct3_FENCE_I 0b1

#define funct3_LB 0b0

#define funct3_LBU 0b100

#define funct3_LD 0b11

#define funct3_LH 0b1

#define funct3_LHU 0b101

#define funct3_LW 0b10

#define funct3_LWU 0b110

#define funct3_MUL 0b0

#define funct3_MULH 0b1

#define funct3_MULHSU 0b10

#define funct3_MULHU 0b11

#define funct3_MULW 0b0

#define funct3_OR 0b110

#define funct3_ORI 0b110

#define funct3_PRIV 0b0

#define funct3_REM 0b110

#define funct3_REMU 0b111

#define funct3_REMUW 0b111

#define funct3_REMW 0b110

#define funct3_SB 0b0

#define funct3_SD 0b11

#define funct3_SH 0b1

#define funct3_SLL 0b1

#define funct3_SLLI 0b1

#define funct3_SLLIW 0b1

#define funct3_SLLW 0b1

#define funct3_SLT 0b10

#define funct3_SLTI 0b10

#define funct3_SLTIU 0b11

#define funct3_SLTU 0b11

#define funct3_SRA 0b101

#define funct3_SRAI 0b101

#define funct3_SRAIW 0b101

#define funct3_SRAW 0b101

#define funct3_SRL 0b101

#define funct3_SRLI 0b101

#define funct3_SRLIW 0b101

#define funct3_SRLW 0b101

#define funct3_SUB 0b0

#define funct3_SUBW 0b0

#define funct3_SW 0b10

#define funct3_XOR 0b100

#define funct3_XORI 0b100

#define funct5_AMOADD 0b0

#define funct5_AMOAND 0b1100

#define funct5_AMOMAX 0b10100

#define funct5_AMOMAXU 0b11100

#define funct5_AMOMIN 0b10000

#define funct5_AMOMINU 0b11000

#define funct5_AMOOR 0b1000

#define funct5_AMOSWAP 0b1

#define funct5_AMOXOR 0b100

#define funct5_LR 0b10

#define funct5_SC 0b11

#define funct6_SLLI 0b0

#define funct6_SRAI 0b10000

#define funct6_SRLI 0b0

#define funct7_ADD 0b0

#define funct7_ADDW 0b0

#define funct7_AND 0b0

#define funct7_DIV 0b1

#define funct7_DIVU 0b1

#define funct7_DIVUW 0b1

#define funct7_DIVW 0b1

#define funct7_MUL 0b1

#define funct7_MULH 0b1

#define funct7_MULHSU 0b1

#define funct7_MULHU 0b1

#define funct7_MULW 0b1

#define funct7_OR 0b0

#define funct7_REM 0b1

#define funct7_REMU 0b1

#define funct7_REMUW 0b1

#define funct7_REMW 0b1

#define funct7_SFENCE_VMA 0b1001

#define funct7_SLL 0b0

#define funct7_SLLIW 0b0

#define funct7_SLLW 0b0

#define funct7_SLT 0b0

#define funct7_SLTU 0b0

#define funct7_SRA 0b100000

#define funct7_SRAIW 0b100000

#define funct7_SRAW 0b100000

#define funct7_SRL 0b0

#define funct7_SRLIW 0b0

#define funct7_SRLW 0b0

#define funct7_SUB 0b100000

#define funct7_SUBW 0b100000

#define funct7_XOR 0b0

bool isValidA(InstructionA inst) {
    switch (inst.kind) {
        case K_InvalidA:
            return false;
        default:
            return true;
    }
}

bool isValidA64(InstructionA64 inst) {
    switch (inst.kind) {
        case K_InvalidA64:
            return false;
        default:
            return true;
    }
}

bool isValidCSR(InstructionCSR inst) {
    switch (inst.kind) {
        case K_InvalidCSR:
            return false;
        default:
            return true;
    }
}

bool isValidI(InstructionI inst) {
    switch (inst.kind) {
        case K_InvalidI:
            return false;
        default:
            return true;
    }
}

bool isValidI64(InstructionI64 inst) {
    switch (inst.kind) {
        case K_InvalidI64:
            return false;
        default:
            return true;
    }
}

bool isValidM(InstructionM inst) {
    switch (inst.kind) {
        case K_InvalidM:
            return false;
        default:
            return true;
    }
}

bool isValidM64(InstructionM64 inst) {
    switch (inst.kind) {
        case K_InvalidM64:
            return false;
        default:
            return true;
    }
}

#define opcode_AMO 0b101111

#define opcode_AUIPC 0b10111

#define opcode_BRANCH 0b1100011

#define opcode_JAL 0b1101111

#define opcode_JALR 0b1100111

#define opcode_LOAD 0b11

#define opcode_LOAD_FP 0b111

#define opcode_LUI 0b110111

#define opcode_MADD 0b1000011

#define opcode_MISC_MEM 0b1111

#define opcode_MSUB 0b1000111

#define opcode_NMADD 0b1001111

#define opcode_NMSUB 0b1001011

#define opcode_OP 0b110011

#define opcode_OP_32 0b111011

#define opcode_OP_FP 0b1010011

#define opcode_OP_IMM 0b10011

#define opcode_OP_IMM_32 0b11011

#define opcode_STORE 0b100011

#define opcode_STORE_FP 0b100111

#define opcode_SYSTEM 0b1110011

bool supportsA(InstructionSet arg_0__) {
    switch (arg_0__) {
        case RV32I:
            return false;
        case RV32IM:
            return false;
        case RV64I:
            return false;
        case RV64IM:
            return false;
        default:
            return true;
    }
}

bool supportsM(InstructionSet arg_0__) {
    switch (arg_0__) {
        case RV32I:
            return false;
        case RV32IA:
            return false;
        case RV64I:
            return false;
        case RV64IA:
            return false;
        default:
            return true;
    }
}

Instruction decode(int iset, InstructionSet inst) {
    int32_t aqrl = bitSlice(inst, 0b11001, 0b11011);
    int32_t funct5 = bitSlice(inst, 0b11011, 0b100000);
    int32_t zimm = bitSlice(inst, 0b1111, 0b10100);
    int32_t funct6 = bitSlice(inst, 0b11010, 0b100000);
    int32_t shamtHi = bitSlice(inst, 0b11001, 0b11010);
    int32_t shamtHiTest = shamtHi == 0b0 || bitwidth(iset) == 0b1000000;
    int32_t shamt6 = bitSlice(inst, 0b10100, 0b11010);
    int32_t shamt5 = bitSlice(inst, 0b10100, 0b11001);
    int32_t sbimm12 = signExtend(0b1101, bitSlice(inst, 0b11111, 0b100000) << 0b1100 | bitSlice(inst, 0b11001, 0b11111) << 0b101 | bitSlice(inst, 0b1000, 0b1100) << 0b1 | bitSlice(inst, 0b111, 0b1000) << 0b1011);
    int32_t simm12 = signExtend(0b1100, bitSlice(inst, 0b11001, 0b100000) << 0b101 | bitSlice(inst, 0b111, 0b1100));
    int32_t csr12 = bitSlice(inst, 0b10100, 0b100000);
    int32_t oimm12 = signExtend(0b1100, bitSlice(inst, 0b10100, 0b100000));
    int32_t imm12 = signExtend(0b1100, bitSlice(inst, 0b10100, 0b100000));
    int32_t jimm20 = signExtend(0b10101, bitSlice(inst, 0b11111, 0b100000) << 0b10100 | bitSlice(inst, 0b10101, 0b11111) << 0b1 | bitSlice(inst, 0b10100, 0b10101) << 0b1011 | bitSlice(inst, 0b1100, 0b10100) << 0b1100);
    int32_t oimm20 = signExtend(0b100000, bitSlice(inst, 0b1100, 0b100000) << 0b1100);
    int32_t imm20 = signExtend(0b100000, bitSlice(inst, 0b1100, 0b100000) << 0b1100);
    int32_t msb4 = bitSlice(inst, 0b11100, 0b100000);
    int32_t pred = bitSlice(inst, 0b11000, 0b11100);
    int32_t succ = bitSlice(inst, 0b10100, 0b11000);
    int32_t rs2 = bitSlice(inst, 0b10100, 0b11001);
    int32_t rs1 = bitSlice(inst, 0b1111, 0b10100);
    int32_t rd = bitSlice(inst, 0b111, 0b1100);
    int32_t funct12 = bitSlice(inst, 0b10100, 0b100000);
    int32_t funct7 = bitSlice(inst, 0b11001, 0b100000);
    int32_t funct3 = bitSlice(inst, 0b1100, 0b1111);
    int32_t opcode = bitSlice(inst, 0b0, 0b111);
    int32_t decodeI = ((opcode == opcode_LOAD && funct3 == funct3_LB)
        ? Lb(rd, rs1, oimm12)
        : ((opcode == opcode_LOAD && funct3 == funct3_LH)
            ? Lh(rd, rs1, oimm12)
            : ((opcode == opcode_LOAD && funct3 == funct3_LW)
                ? Lw(rd, rs1, oimm12)
                : ((opcode == opcode_LOAD && funct3 == funct3_LBU)
                    ? Lbu(rd, rs1, oimm12)
                    : ((opcode == opcode_LOAD && funct3 == funct3_LHU)
                        ? Lhu(rd, rs1, oimm12)
                        : ((opcode == opcode_MISC_MEM && rd == 0b0 && funct3 == funct3_FENCE && rs1 == 0b0 && msb4 == 0b0)
                            ? Fence(pred, succ)
                            : ((opcode == opcode_MISC_MEM && rd == 0b0 && funct3 == funct3_FENCE_I && rs1 == 0b0 && imm12 == 0b0)
                                ? Fence_i()
                                : ((opcode == opcode_OP_IMM && funct3 == funct3_ADDI)
                                    ? Addi(rd, rs1, imm12)
                                    : ((opcode == opcode_OP_IMM && funct3 == funct3_SLTI)
                                        ? Slti(rd, rs1, imm12)
                                        : ((opcode == opcode_OP_IMM && funct3 == funct3_SLTIU)
                                            ? Sltiu(rd, rs1, imm12)
                                            : ((opcode == opcode_OP_IMM && funct3 == funct3_XORI)
                                                ? Xori(rd, rs1, imm12)
                                                : ((opcode == opcode_OP_IMM && funct3 == funct3_ORI)
                                                    ? Ori(rd, rs1, imm12)
                                                    : ((opcode == opcode_OP_IMM && funct3 == funct3_ANDI)
                                                        ? Andi(rd, rs1, imm12)
                                                        : ((opcode == opcode_OP_IMM && funct3 == funct3_SLLI && funct6 == funct6_SLLI && shamtHiTest)
                                                            ? Slli(rd, rs1, shamt6)
                                                            : ((opcode == opcode_OP_IMM && funct3 == funct3_SRLI && funct6 == funct6_SRLI && shamtHiTest)
                                                                ? Srli(rd, rs1, shamt6)
                                                                : ((opcode == opcode_OP_IMM && funct3 == funct3_SRAI && funct6 == funct6_SRAI && shamtHiTest)
                                                                    ? Srai(rd, rs1, shamt6)
                                                                    : ((opcode == opcode_AUIPC)
                                                                        ? Auipc(rd, oimm20)
                                                                        : ((opcode == opcode_STORE && funct3 == funct3_SB)
                                                                            ? Sb(rs1, rs2, simm12)
                                                                            : ((opcode == opcode_STORE && funct3 == funct3_SH)
                                                                                ? Sh(rs1, rs2, simm12)
                                                                                : ((opcode == opcode_STORE && funct3 == funct3_SW)
                                                                                    ? Sw(rs1, rs2, simm12)
                                                                                    : ((opcode == opcode_OP && funct3 == funct3_ADD && funct7 == funct7_ADD)
                                                                                        ? Add(rd, rs1, rs2)
                                                                                        : ((opcode == opcode_OP && funct3 == funct3_SUB && funct7 == funct7_SUB)
                                                                                            ? Sub(rd, rs1, rs2)
                                                                                            : ((opcode == opcode_OP && funct3 == funct3_SLL && funct7 == funct7_SLL)
                                                                                                ? Sll(rd, rs1, rs2)
                                                                                                : ((opcode == opcode_OP && funct3 == funct3_SLT && funct7 == funct7_SLT)
                                                                                                    ? Slt(rd, rs1, rs2)
                                                                                                    : ((opcode == opcode_OP && funct3 == funct3_SLTU && funct7 == funct7_SLTU)
                                                                                                        ? Sltu(rd, rs1, rs2)
                                                                                                        : ((opcode == opcode_OP && funct3 == funct3_XOR && funct7 == funct7_XOR)
                                                                                                            ? Xor(rd, rs1, rs2)
                                                                                                            : ((opcode == opcode_OP && funct3 == funct3_SRL && funct7 == funct7_SRL)
                                                                                                                ? Srl(rd, rs1, rs2)
                                                                                                                : ((opcode == opcode_OP && funct3 == funct3_SRA && funct7 == funct7_SRA)
                                                                                                                    ? Sra(rd, rs1, rs2)
                                                                                                                    : ((opcode == opcode_OP && funct3 == funct3_OR && funct7 == funct7_OR)
                                                                                                                        ? Or(rd, rs1, rs2)
                                                                                                                        : ((opcode == opcode_OP && funct3 == funct3_AND && funct7 == funct7_AND)
                                                                                                                            ? And(rd, rs1, rs2)
                                                                                                                            : ((opcode == opcode_LUI)
                                                                                                                                ? Lui(rd, imm20)
                                                                                                                                : ((opcode == opcode_BRANCH && funct3 == funct3_BEQ)
                                                                                                                                    ? Beq(rs1, rs2, sbimm12)
                                                                                                                                    : ((opcode == opcode_BRANCH && funct3 == funct3_BNE)
                                                                                                                                        ? Bne(rs1, rs2, sbimm12)
                                                                                                                                        : ((opcode == opcode_BRANCH && funct3 == funct3_BLT)
                                                                                                                                            ? Blt(rs1, rs2, sbimm12)
                                                                                                                                            : ((opcode == opcode_BRANCH && funct3 == funct3_BGE)
                                                                                                                                                ? Bge(rs1, rs2, sbimm12)
                                                                                                                                                : ((opcode == opcode_BRANCH && funct3 == funct3_BLTU)
                                                                                                                                                    ? Bltu(rs1, rs2, sbimm12)
                                                                                                                                                    : ((opcode == opcode_BRANCH && funct3 == funct3_BGEU)
                                                                                                                                                        ? Bgeu(rs1, rs2, sbimm12)
                                                                                                                                                        : ((opcode == opcode_JALR)
                                                                                                                                                            ? Jalr(rd, rs1, oimm12)
                                                                                                                                                            : ((opcode == opcode_JAL)
                                                                                                                                                                ? Jal(rd, jimm20)
                                                                                                                                                                : InvalidI())))))))))))))))))))))))))))))))))))))));
    int32_t decodeM = ((opcode == opcode_OP && funct3 == funct3_MUL && funct7 == funct7_MUL)
        ? Mul(rd, rs1, rs2)
        : ((opcode == opcode_OP && funct3 == funct3_MULH && funct7 == funct7_MULH)
            ? Mulh(rd, rs1, rs2)
            : ((opcode == opcode_OP && funct3 == funct3_MULHSU && funct7 == funct7_MULHSU)
                ? Mulhsu(rd, rs1, rs2)
                : ((opcode == opcode_OP && funct3 == funct3_MULHU && funct7 == funct7_MULHU)
                    ? Mulhu(rd, rs1, rs2)
                    : ((opcode == opcode_OP && funct3 == funct3_DIV && funct7 == funct7_DIV)
                        ? Div(rd, rs1, rs2)
                        : ((opcode == opcode_OP && funct3 == funct3_DIVU && funct7 == funct7_DIVU)
                            ? Divu(rd, rs1, rs2)
                            : ((opcode == opcode_OP && funct3 == funct3_REM && funct7 == funct7_REM)
                                ? Rem(rd, rs1, rs2)
                                : ((opcode == opcode_OP && funct3 == funct3_REMU && funct7 == funct7_REMU)
                                    ? Remu(rd, rs1, rs2)
                                    : InvalidM()))))))));
    int32_t decodeA = ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_LR && rs2 == 0b0)
        ? Lr_w(rd, rs1, aqrl)
        : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_SC)
            ? Sc_w(rd, rs1, rs2, aqrl)
            : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_AMOSWAP)
                ? Amoswap_w(rd, rs1, rs2, aqrl)
                : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_AMOADD)
                    ? Amoadd_w(rd, rs1, rs2, aqrl)
                    : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_AMOXOR)
                        ? Amoxor_w(rd, rs1, rs2, aqrl)
                        : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_AMOAND)
                            ? Amoand_w(rd, rs1, rs2, aqrl)
                            : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_AMOOR)
                                ? Amoor_w(rd, rs1, rs2, aqrl)
                                : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_AMOMIN)
                                    ? Amomin_w(rd, rs1, rs2, aqrl)
                                    : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_AMOMAX)
                                        ? Amomax_w(rd, rs1, rs2, aqrl)
                                        : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_AMOMINU)
                                            ? Amominu_w(rd, rs1, rs2, aqrl)
                                            : ((opcode == opcode_AMO && funct3 == funct3_AMOW && funct5 == funct5_AMOMAXU)
                                                ? Amomaxu_w(rd, rs1, rs2, aqrl)
                                                : InvalidA())))))))))));
    int32_t decodeI64 = ((opcode == opcode_LOAD && funct3 == funct3_LD)
        ? Ld(rd, rs1, oimm12)
        : ((opcode == opcode_LOAD && funct3 == funct3_LWU)
            ? Lwu(rd, rs1, oimm12)
            : ((opcode == opcode_OP_IMM_32 && funct3 == funct3_ADDIW)
                ? Addiw(rd, rs1, imm12)
                : ((opcode == opcode_OP_IMM_32 && funct3 == funct3_SLLIW && funct7 == funct7_SLLIW)
                    ? Slliw(rd, rs1, shamt5)
                    : ((opcode == opcode_OP_IMM_32 && funct3 == funct3_SRLIW && funct7 == funct7_SRLIW)
                        ? Srliw(rd, rs1, shamt5)
                        : ((opcode == opcode_OP_IMM_32 && funct3 == funct3_SRAIW && funct7 == funct7_SRAIW)
                            ? Sraiw(rd, rs1, shamt5)
                            : ((opcode == opcode_STORE && funct3 == funct3_SD)
                                ? Sd(rs1, rs2, simm12)
                                : ((opcode == opcode_OP_32 && funct3 == funct3_ADDW && funct7 == funct7_ADDW)
                                    ? Addw(rd, rs1, rs2)
                                    : ((opcode == opcode_OP_32 && funct3 == funct3_SUBW && funct7 == funct7_SUBW)
                                        ? Subw(rd, rs1, rs2)
                                        : ((opcode == opcode_OP_32 && funct3 == funct3_SLLW && funct7 == funct7_SLLW)
                                            ? Sllw(rd, rs1, rs2)
                                            : ((opcode == opcode_OP_32 && funct3 == funct3_SRLW && funct7 == funct7_SRLW)
                                                ? Srlw(rd, rs1, rs2)
                                                : ((opcode == opcode_OP_32 && funct3 == funct3_SRAW && funct7 == funct7_SRAW)
                                                    ? Sraw(rd, rs1, rs2)
                                                    : InvalidI64()))))))))))));
    int32_t decodeM64 = ((opcode == opcode_OP_32 && funct3 == funct3_MULW && funct7 == funct7_MULW)
        ? Mulw(rd, rs1, rs2)
        : ((opcode == opcode_OP_32 && funct3 == funct3_DIVW && funct7 == funct7_DIVW)
            ? Divw(rd, rs1, rs2)
            : ((opcode == opcode_OP_32 && funct3 == funct3_DIVUW && funct7 == funct7_DIVUW)
                ? Divuw(rd, rs1, rs2)
                : ((opcode == opcode_OP_32 && funct3 == funct3_REMW && funct7 == funct7_REMW)
                    ? Remw(rd, rs1, rs2)
                    : ((opcode == opcode_OP_32 && funct3 == funct3_REMUW && funct7 == funct7_REMUW)
                        ? Remuw(rd, rs1, rs2)
                        : InvalidM64())))));
    int32_t decodeA64 = ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_LR && rs2 == 0b0)
        ? Lr_d(rd, rs1, aqrl)
        : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_SC)
            ? Sc_d(rd, rs1, rs2, aqrl)
            : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_AMOSWAP)
                ? Amoswap_d(rd, rs1, rs2, aqrl)
                : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_AMOADD)
                    ? Amoadd_d(rd, rs1, rs2, aqrl)
                    : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_AMOXOR)
                        ? Amoxor_d(rd, rs1, rs2, aqrl)
                        : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_AMOAND)
                            ? Amoand_d(rd, rs1, rs2, aqrl)
                            : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_AMOOR)
                                ? Amoor_d(rd, rs1, rs2, aqrl)
                                : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_AMOMIN)
                                    ? Amomin_d(rd, rs1, rs2, aqrl)
                                    : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_AMOMAX)
                                        ? Amomax_d(rd, rs1, rs2, aqrl)
                                        : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_AMOMINU)
                                            ? Amominu_d(rd, rs1, rs2, aqrl)
                                            : ((opcode == opcode_AMO && funct3 == funct3_AMOD && funct5 == funct5_AMOMAXU)
                                                ? Amomaxu_d(rd, rs1, rs2, aqrl)
                                                : InvalidA64())))))))))));
    int32_t decodeCSR = ((opcode == opcode_SYSTEM && rd == 0b0 && funct3 == funct3_PRIV && funct7 == funct7_SFENCE_VMA)
        ? Sfence_vma(rs1, rs2)
        : ((opcode == opcode_SYSTEM && rd == 0b0 && funct3 == funct3_PRIV && rs1 == 0b0 && funct12 == funct12_ECALL)
            ? Ecall()
            : ((opcode == opcode_SYSTEM && rd == 0b0 && funct3 == funct3_PRIV && rs1 == 0b0 && funct12 == funct12_EBREAK)
                ? Ebreak()
                : ((opcode == opcode_SYSTEM && rd == 0b0 && funct3 == funct3_PRIV && rs1 == 0b0 && funct12 == funct12_URET)
                    ? Uret()
                    : ((opcode == opcode_SYSTEM && rd == 0b0 && funct3 == funct3_PRIV && rs1 == 0b0 && funct12 == funct12_SRET)
                        ? Sret()
                        : ((opcode == opcode_SYSTEM && rd == 0b0 && funct3 == funct3_PRIV && rs1 == 0b0 && funct12 == funct12_MRET)
                            ? Mret()
                            : ((opcode == opcode_SYSTEM && rd == 0b0 && funct3 == funct3_PRIV && rs1 == 0b0 && funct12 == funct12_WFI)
                                ? Wfi()
                                : ((opcode == opcode_SYSTEM && funct3 == funct3_CSRRW)
                                    ? Csrrw(rd, rs1, csr12)
                                    : ((opcode == opcode_SYSTEM && funct3 == funct3_CSRRS)
                                        ? Csrrs(rd, rs1, csr12)
                                        : ((opcode == opcode_SYSTEM && funct3 == funct3_CSRRC)
                                            ? Csrrc(rd, rs1, csr12)
                                            : ((opcode == opcode_SYSTEM && funct3 == funct3_CSRRWI)
                                                ? Csrrwi(rd, zimm, csr12)
                                                : ((opcode == opcode_SYSTEM && funct3 == funct3_CSRRSI)
                                                    ? Csrrsi(rd, zimm, csr12)
                                                    : ((opcode == opcode_SYSTEM && funct3 == funct3_CSRRCI)
                                                        ? Csrrci(rd, zimm, csr12)
                                                        : InvalidCSR())))))))))))));
    int32_t resultCSR = ((isValidCSR(decodeCSR))
        ? make_list(CSRInstruction(decodeCSR))
        : make_list());
    int32_t resultA64 = ((isValidA64(decodeA64))
        ? make_list(A64Instruction(decodeA64))
        : make_list());
    int32_t resultM64 = ((isValidM64(decodeM64))
        ? make_list(M64Instruction(decodeM64))
        : make_list());
    int32_t resultI64 = ((isValidI64(decodeI64))
        ? make_list(I64Instruction(decodeI64))
        : make_list());
    int32_t resultA = ((isValidA(decodeA))
        ? make_list(AInstruction(decodeA))
        : make_list());
    int32_t resultM = ((isValidM(decodeM))
        ? make_list(MInstruction(decodeM))
        : make_list());
    int32_t resultI = ((isValidI(decodeI))
        ? make_list(IInstruction(decodeI))
        : make_list());
    int32_t results = resultI + ((supportsM(iset))
        ? resultM
        : make_list()) + ((supportsA(iset))
        ? resultA
        : make_list()) + ((bitwidth(iset) == 0b1000000)
        ? resultI64
        : make_list()) + ((bitwidth(iset) == 0b1000000 && supportsM(iset))
        ? resultM64
        : make_list()) + ((bitwidth(iset) == 0b1000000 && supportsA(iset))
        ? resultA64
        : make_list()) + resultCSR;
    if (len(results) > 0b1) {
        return InvalidInstruction(inst);
    } else {
        return list_nth_default(0b0, results, InvalidInstruction(inst));
    }
}

