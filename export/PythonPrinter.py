from LanguagePrinter import LanguagePrinter

class PythonPrinter(LanguagePrinter):
    def __init__(self, outfile):
        super(PythonPrinter, self).__init__(outfile)
        self.comment('This Python file was autogenerated from Coq')
        self.writeln('from enum import Enum')
        self.writeln('import ZBitOps')
        self.writeln('from Utility import *')
        self.end_decl()

    def comment(self, s):
        self.writeln('# ' + s)

    def end_decl(self):
        self.writeln('')

    def type_alias(self, name, rhsName):
        pass # there are no types aliases in Python

    def enum(self, name, valueNames):
        self.writeln('class {}(Enum):'.format(name))
        for i, n in enumerate(valueNames, 1):
            self.writeln('    ' + n + ' = ' + str(i))
        self.end_decl()

    def variant(self, name, branches):
        '''
        name: str
        branches: list of (branchName, typesList) tuples
        '''
        self.writeln('class {}(object): pass'.format(name))
        self.end_decl()

        for branchName, argTypes in branches:
            self.writeln('class {}({}):'.format(branchName, name))
            self.increaseIndent()
            constructorArgs = ''.join([', f' + str(i) for i in range(len(argTypes))])
            self.writeln('def __init__(self{}):'.format(constructorArgs))
            self.increaseIndent()
            for i in range(len(argTypes)):
                self.writeln('self.f{} = f{}'.format(i, i))
            if len(argTypes) == 0:
                self.writeln('pass')
            self.decreaseIndent()
            self.decreaseIndent()
            self.end_decl()

    def if_stmt(self, cond, ifyes, ifno):
        self.startln()
        self.write('if ')
        cond()
        self.write(':\n')
        self.increaseIndent()
        self.startln()
        ifyes()
        self.write('\n')
        self.decreaseIndent()
        self.startln()
        self.write("else:\n")
        self.increaseIndent()
        self.startln()
        ifno()
        self.write("\n")
        self.decreaseIndent()

    def if_expr(self, cond, ifyes, ifno):
        self.write('(')
        ifyes()
        self.write("\n")
        self.increaseIndent()
        self.startln()
        self.write(" if ")
        cond()
        self.write("\n")
        self.startln()
        self.write(" else ")
        ifno()
        self.write(')')
        self.decreaseIndent()

    def list(self, elems):
        self.write('[')
        sep = ''
        for elem in elems:
            self.write(sep)
            sep = ', '
            elem()
        self.write(']')

    def list_length(self, first_arg):
        self.write("len(")
        first_arg()
        self.write(")")

    def list_nth_default(self, index, l, default):
        self.write("list_nth_default(")
        index()
        self.write(', ')
        l()
        self.write(', ')
        default()
        self.write(')')

    def concat(self, first_arg, second_arg):
        first_arg()
        self.write(' + ')
        second_arg()

    def equality(self, first_arg, second_arg):
        first_arg()
        self.write(' == ')
        second_arg()

    def gt(self, first_arg, second_arg):
        first_arg()
        self.write(' > ')
        second_arg()

    def logical_or(self, first_arg, second_arg):
        first_arg()
        self.write(' | ')
        second_arg()

    def shift_left(self, first_arg, second_arg):
        first_arg()
        self.write(' << ')
        second_arg()

    def boolean_and(self, first_arg, second_arg):
        first_arg()
        self.write(' and ')
        second_arg()

    def boolean_or(self, first_arg, second_arg):
        first_arg()
        self.write(' or ')
        second_arg()

    def let_in(self, name, typ, rhs, body):
        self.startln()
        self.write(name + ' = ')
        rhs()
        self.end_decl()
        body()

    def constant_decl(self, name, typ, rhs):
        self.write(name + ' = ')
        rhs()
        self.write('\n')
        self.end_decl()

    def function_call(self, func, args):
        func()
        self.write('(')
        sep = ''
        for arg in args:
            self.write(sep)
            sep = ', '
            arg()
        self.write(')')

    def bit_literal(self, s):
        self.write('0b' + s)

    def true_literal(self):
        self.write('True')

    def false_literal(self):
        self.write('False')

    def var(self, varName):
        self.write(varName)

    def fun_decl(self, name, argnamesWithTypes, returnType, body):
        self.writeln('def {}({}):'.format(name,
                ', '.join([argname for argname, tp in argnamesWithTypes])))
        self.increaseIndent()
        body()
        self.decreaseIndent()
        self.end_decl()

    # match over Inductive (where constructors can take args)
    def match(self, discriminee, branches, default_branch):
        for constructorName, branchBody in branches.items():
            self.writeln('if isinstance({}, {}):'.format(discriminee, constructorName))
            self.increaseIndent()
            self.startln()
            branchBody() # TODO make sure branch body can access fields
            self.decreaseIndent()
            self.write('\n')
        if default_branch:
            self.startln()
            default_branch()
            self.write('\n')

    # match over an enum (where constructors cannot take args)
    def switch(self, discriminee, enumName, branches, default_branch):
        for constructorName, branchBody in branches.items():
            self.writeln('if {} == {}.{}:'.format(discriminee, enumName, constructorName))
            self.increaseIndent()
            self.startln()
            branchBody()
            self.decreaseIndent()
            self.write('\n')
        if default_branch:
            self.startln()
            default_branch()
            self.write('\n')

    def begin_return_expr(self):
        self.write('return ')

    def end_return_expr(self):
        pass # nothing to be done

    def nop(self):
        self.writeln('pass')
