from LanguagePrinter import LanguagePrinter


type_mappings = {
    'BinNums.Z': 'int',
    'Datatypes.bool': 'bool'
}


def convert_type(t):
    global type_mappings
    res = type_mappings.get(t)
    if res:
        return res
    else:
        return t

lib = '''
int32_t bitSlice(int32_t w, int32_t start, int32_t stop) {
    int32_t mask = (1 << (stop - start)) - 1;
    return (w >> start) & mask;
}

int32_t signExtend(int32_t l, int32_t n) {
    if ((n >> (l - 1)) & 1) {
        return n - (1 << l);
    } else {
        return n;
    }
}
'''

InstructionListCode = '''
typedef struct {
    Instruction inst;
    int size;
} InstructionList;

InstructionList empty_instruction_list() {
    InstructionList res = { InvalidInstruction(0), 0 };
    return res;
}

InstructionList singleton_instruction_list(Instruction i) {
    InstructionList res = { i, 1 };
    return res;
}

InstructionList concat_instruction_list(InstructionList l1, InstructionList l2) {
    if (l1.size == 0) {
        return l2;
    }
    if (l2.size == 0) {
        return l1;
    }
    InstructionList res = { InvalidInstruction(0), 2 }; // 2 means "more than 1"
    return res;
}

Instruction instruction_list_head_default(InstructionList l, Instruction deflt) {
    if (l.size == 1) {
        return l.inst;
    } else {
        return deflt;
    }
}
'''

class CPrinter(LanguagePrinter):
    def __init__(self, outfile):
        super(CPrinter, self).__init__(outfile)
        self.expr = CExpressionPrinter(self)
        self.stmt = CStatementPrinter(self)
        self.comment('This C file was autogenerated from Coq')
        self.writeln('#include <stdbool.h>')
        self.writeln('#include <stdint.h>')
        self.end_decl()
        self.writeln(lib)

    def end_decl(self):
        self.writeln('')

    def comment(self, s):
        self.writeln('// ' + s)

    def type_alias(self, name, rhsName):
        self.writeln('#define {} {}'.format(name, convert_type(rhsName)))
        self.end_decl()

    def enum(self, name, valueNames):
        self.writeln('typedef enum {' + ', '.join(valueNames) + '} ' + name + ';')
        self.end_decl()

    def __variant_struct(self, name, branches):
        '''
        name: str
        branches: list of (branchName, typesList) tuples
        '''
        self.writeln('typedef struct {')
        self.increaseIndent()
        self.writeln('{}_kind kind;'.format(name))
        # note: anonymous unions require "-std=c11"
        self.writeln('union {')
        self.increaseIndent()
        for branchName, argTypes in branches:
            self.writeln('struct {')
            self.increaseIndent()
            for i, t in enumerate(argTypes):
                self.writeln('{} f{};'.format(convert_type(t), i))
            self.decreaseIndent()
            self.writeln('} as_' + branchName + ';')
        self.decreaseIndent()
        self.writeln('};')
        self.decreaseIndent()
        self.writeln('} ' + name + ';')
        self.end_decl()

    def __variant_constructors(self, name, branches):
        '''
        Prints something like

        InstructionCSR Sfence_vma(Register f_0, Register f_1) {
            InstructionCSR res = { K_Sfence_vma, { .as_Sfence_vma = {f_0, f_1} } };
            return res;
        }

        for each constructor
        '''
        for branchName, argTypes in branches:
            params = ', '.join(['{} f_{}'.format(convert_type(t), i)
                                for i, t in enumerate(argTypes)])
            self.writeln('{} {}({}) {{'.format(name, branchName, params))
            self.increaseIndent()
            self.startln()
            self.write(name)
            self.write(' res = {K_')
            self.write(branchName)
            self.write(', { .as_')
            self.write(branchName)
            self.write(' = {')
            self.write(', '.join(['f_{}'.format(i) for i in range(len(argTypes))]))
            self.write('} } };\n')
            self.writeln('return res;')
            self.decreaseIndent()
            self.writeln('}')
            self.end_decl()

    def variant(self, name, branches):
        '''
        name: str
        branches: list of (branchName, typesList) tuples
        '''
        self.enum(name + '_kind', ['K_' + b[0] for b in branches])
        self.__variant_struct(name, branches)
        self.__variant_constructors(name, branches)
        if name == 'Instruction':
            self.writeln(InstructionListCode)

    def constant_decl(self, name, typ, rhs):
        self.writeln('#define ' + name + ' ' + rhs() + '\n')

    def fun_decl(self, name, argnamesWithTypes, returnType, body):
        self.writeln('{} {}({}) {{'.format(convert_type(returnType), name,
            ', '.join([convert_type(tp) + ' ' + argname for argname, tp in argnamesWithTypes])))
        self.increaseIndent()
        self.startln()
        self.write(body())
        self.decreaseIndent()
        self.writeln('}')
        self.end_decl()



class CExpressionPrinter:

    def __init__(self, context):
        self.context = context

    # private helper functions:

    def __binop(self, arg1, op, arg2):
        return "{} {} {}".format(arg1(), op, arg2())

    def __raw_function_call(self, func, args):
        return '{}({})'.format(func, ', '.join(args))


    # public functions:

    def function_call(self, func, args):
        return self.__raw_function_call(func(), [arg() for arg in args])

    def bit_literal(self, s):
        return '0b' + s # gcc extension

    def true_literal(self):
        return 'true'

    def false_literal(self):
        return 'false'

    def var(self, varName):
        return varName.split('.')[-1]

    def if_expr(self, cond, ifyes, ifno):
        res = '((' + cond() + ")\n"
        self.context.increaseIndent()
        res += self.context.indent + "? " + ifyes() + "\n"
        res += self.context.indent + ": " + ifno() + ')'
        self.context.decreaseIndent()
        return res

    def list(self, elems):
        if len(elems) == 0:
            return 'empty_instruction_list()';
        elif len(elems) == 1:
            return 'singleton_instruction_list(' + elems[0]() + ')';
        else:
            raise ValueError('instruction lists of size other than 0 and 1 are not supported')

    def list_length(self, arg):
        return arg() + '.size'

    def list_nth_default(self, index, l, default):
        assert(index() == '0b0')
        return self.__raw_function_call("instruction_list_head_default", [l(), default()])

    def concat(self, first_arg, second_arg):
        return self.__raw_function_call("concat_instruction_list", [first_arg(), second_arg()])

    def equality(self, first_arg, second_arg):
        return self.__binop(first_arg, '==', second_arg)

    def gt(self, first_arg, second_arg):
        return self.__binop(first_arg, '>', second_arg)

    def logical_or(self, first_arg, second_arg):
        return self.__binop(first_arg, '|', second_arg)

    def shift_left(self, first_arg, second_arg):
        return self.__binop(first_arg, '<<', second_arg)

    def boolean_and(self, first_arg, second_arg):
        return self.__binop(first_arg, '&&', second_arg)

    def boolean_or(self, first_arg, second_arg):
        return self.__binop(first_arg, '||', second_arg)


class CStatementPrinter:

    def __init__(self, context):
        self.context = context

    def if_stmt(self, cond, ifyes, ifno):
        res = 'if ('
        res += cond()
        res += ') {\n'
        self.context.increaseIndent()
        res += self.context.indent
        res += ifyes()
        res += '\n'
        self.context.decreaseIndent()
        res += self.context.indent
        res += "} else {\n"
        self.context.increaseIndent()
        res += self.context.indent
        res += ifno()
        res += '\n'
        self.context.decreaseIndent()
        res += self.context.indent
        res += "}\n"
        return res

    def let_in(self, name, typ, rhs, body):
        res = convert_type(typ) + ' ' + name + ' = '
        res += rhs()
        res += ';\n' + self.context.indent
        res += body()
        return res

    def nop(self):
        return 'pass'

    # match over Inductive (where constructors can take args)
    def match(self, discriminee, branches, default_branch):
        res = 'switch ({}.kind) {{\n'.format(discriminee)
        self.context.increaseIndent()
        for constructorName, branchBody in branches.items():
            res += self.context.indent
            res += 'case K_{}:\n'.format(constructorName)
            self.context.increaseIndent()
            res += self.context.indent
            res += branchBody()
            self.context.decreaseIndent()
            res += '\n'
        if default_branch:
            res += self.context.indent
            res += 'default:\n'.format(constructorName)
            self.context.increaseIndent()
            res += self.context.indent
            res += default_branch()
            self.context.decreaseIndent()
            res += '\n'
        self.context.decreaseIndent()
        res += self.context.indent + '}\n'
        return res

    # match over an enum (where constructors cannot take args)
    def switch(self, discriminee, enumName, branches, default_branch):
        res = 'switch ({}) {{\n'.format(discriminee)
        self.context.increaseIndent()
        for constructorName, branchBody in branches.items():
            res += self.context.indent
            res += 'case {}:\n'.format(constructorName)
            self.context.increaseIndent()
            res += self.context.indent
            res += branchBody()
            self.context.decreaseIndent()
            res += '\n'
        if default_branch:
            res += self.context.indent
            res += 'default:\n'.format(constructorName)
            self.context.increaseIndent()
            res += self.context.indent
            res += default_branch()
            self.context.decreaseIndent()
            res += '\n'
        self.context.decreaseIndent()
        res += self.context.indent + '}\n'
        return res

    def return_value(self, e):
        return "return " + e + ";"
